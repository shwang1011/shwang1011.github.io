[{"title":"1.3程序控制结构","date":"2016-12-24T11:50:39.000Z","path":"2016/12/24/1-3程序控制结构/","text":"Python的程序控制结构： 1.顺序结构 2.分支结构 3.循环结构 Python中的布尔测试： 1.任何非零的数字或对象都为True 2.数字零、空对象及特殊对象None都为False 3.比较运算会返回True或False 4.逻辑运算会返回True或False 1.3.1 顺序结构顺序结构，顾名思义就是从上到下顺序执行程序。 1234In [1]: a = 10In [2]: a += 1In [3]: print('a = &#123;0&#125;'.format(a))a = 11 1.3.2 分之结构1.3.2.1 单分支 语法： 123if condition: blockmain block 流程： 例： 12345a = 4b = 5if a &lt; b: print('a less than b')输出：a less than b 1.3.2.2 双分支 语法： 12345if condition: true_blockelse: false_blockmain block 流程： 例： 1234567a = 4b = 5if a &gt; b: print('a larger than b')else: print('a less than b')输出：a less than b 1.3.2.3 多分支 语法： 12345678910if condition1: block1elif condition2: block2elif conditionN: blockN......else: else_blockmain block 流程： 例： 123456789a = 4b = 5if a &gt; b: print('a larger than b')elif a == b: print('a equal to b')else: print('a less than b')输出：a less than b","tags":[{"name":"python","slug":"python","permalink":"http://www.linuxer.vip/tags/python/"}]},{"title":"Nginx配置","date":"2016-12-20T13:02:54.000Z","path":"2016/12/20/Nginx配置/","text":"Locationnginx可以使用location指令根据请求报文URI将请求转发至其他主机或者本地主机的其他位置。 语法：location [=|^~|~|~*] uri {…}使用位置：server，location意义：匹配http请求报文URI，执行响应的配置 匹配类型： prefix strings（前缀字符串匹配） regular expressions（正则表达式匹配） ：前缀字符串匹配，优先级最低 =：表示前缀字符串精确匹配URI，优先级最高 ^~：表示前缀字符串匹配URI前半部分（URI以xxx字符串开头） ~：区分大小写的正则匹配 ~*：不区分大小写的正则匹配 为了找到最佳匹配的URI，nginx首先比较前缀字符串的location，然后查询正则表达式的location。在前缀字符串中选择最长最佳的匹配。 location处理逻辑： 1.用URI测试所有的prefix string;2.URI精确匹配到=定义的location，使用这个location，停止搜索3.匹配最长prefix string，如果这个最长prefix string带有^~修饰符，使用这个location，停止搜索，否则进行#4步操作4.存储这个最长匹配prefix string5.然后匹配正则表达式6.匹配到第一条正则表达式，使用这个location，停止搜索；7.没有匹配到正则表达式，使用#4步存储的prefix string的location。 = 的典型用例：123location = / &#123; ....&#125; 如果请求/非常频繁，使用上面的配置会加快处理速度，因为执行完#2步就完成了匹配。 Return返回指定状态码：123location /wront/url &#123; return 404;&#125; return指令的第一个参数是响应状态码，第二个可选参数可以是重定向的RUL(for code 301,302,303 and 307)或者一段文本，如：123location /permanently/moved/url &#123; return 301 http://www.example.com/moved/url;&#125; Rewrite一个请求的RUI可以被rewrite指令重写多次。rewrite指令有两个必选参数和一个可选参数： regular expression（必选，匹配URI的正则表达式） 第二个必选参数是URI，用来替代匹配到的URI 可选参数是一个标志，此标志可以停止rewrite指令的下一步操作或者发送一个redirect状态码301或302 例如：1234567server &#123; ... rewrite ^(/download/.*)/media/(.*)\\..*$ $1/mp3/$2.mp3 last; rewrite ^(/download/.*)/audio/(.*)\\..*$ $1/mp3/$2.ra last; return 403; ...&#125; 根据上面的举例，/download/some/media/file被重写为/download/some/mp3/file.mp3，而后使用/download/some/mp3/file.mp3重新发起请求，第二个rewrite和return被跳过。/download/some/audio/file被重写为/download/some/mp3/file.ra，，而后使用/download/some/mp3/file.ra重新发起请求，return被跳过。如果URI没有被任何rewrite规则匹配到，nginx将返回403错误。 rewrite标志：空:一旦被当前规则匹配并重写后，继续检查后续其它的rewrite规则，直至最后一条，而后使用重写后的URI重新发起请求last：一旦被当前规则匹配并重写后，立即停止检查后续其它的rewrite规则，而后通过重写后的URI重新发起请求break：一旦被当前规则匹配并重写后，立即停止检查后续其它的rewrite规则，而后继续由nginx进行后续操作redirect：返回302临时重定向状态码permanent：返回301永久重定向状态码","tags":[{"name":"Nginx","slug":"Nginx","permalink":"http://www.linuxer.vip/tags/Nginx/"}]},{"title":"1.2运算符","date":"2016-12-14T09:04:55.000Z","path":"2016/12/14/1-2运算符/","text":"1.2.1 算术运算符算术运算符通常只针对数值类型。 算术运算符 说明 + 加法 - 减法 * 乘法 / 自然除 // 取整除 ** 幂 % 取模(求余数) 注：Python2.X中/是取整除，实现自然除可以使用float(3)/5或3.0/5 示例：1234567891011121314In [5]: 6 + 5Out[5]: 11In [6]: 6 - 5Out[6]: 1In [7]: 6 * 5Out[7]: 30In [8]: 6 / 5Out[8]: 1.2In [9]: 6 // 5Out[9]: 1In [10]: 2 ** 3Out[10]: 8In [12]: 7 % 5Out[12]: 2 注意：1234In [1]: 1 - 0.9Out[1]: 0.09999999999999998 In [3]: round(1-0.9,1)Out[3]: 0.1 1.2.2 比较运算符运算结果返回True或False。 比较运算符 说明 &gt; 大于 &lt; 小于 &gt;= 大于等于 &lt;= 小于等于 == 等于 != 不等于 示例：1234567891011121314In [1]: 3 &gt; 2Out[1]: TrueIn [2]: 5 &lt; 6Out[2]: TrueIn [3]: 4 &gt;= 3Out[3]: TrueIn [4]: 5 &lt;= 4Out[4]: FalseIn [5]: 5 == 5Out[5]: TrueIn [6]: 'abc' == 'abc'Out[6]: TrueIn [7]: 1 != 2Out[7]: True 注：除了==和!=最好比较的数据类型相同。 1.2.3 逻辑运算符参与运算的成员只能是布尔类型，或者 逻辑运算符 说明 and 与，双目运算 or 或，双目运算 not 非，单目运算 and： True and True = TrueTrue and False = FalseFalse and True = FalseFalse and False = False or： True or True = TrueTrue or False = TrueFalse or True = TrueFalse or False = False not： not True = Falsenot False = True 短路操作：逻辑运算总是 从左到右 的计算，一旦能够决定整个表达式的最终结果，将立即停止运算并返回结果。如：1234567x = 3y = 4x + y &lt; y -x and ...anything... //and左边为False，不管and右边是True或者False，整个表达式的结果都是False，所以不会执行and右边的...anything...x + y &gt; y -x or ...anything... //and左边为True，不管and右边是True或者False，整个表达式的结果都是True，所以不会执行and右边的...anything... 1.2.4 位运算符Python中很少用到，暂时不做介绍。 1.2.5 成员运算符in和not in，后续介绍。 1.2.6 身份运算符is和not is，后续介绍。 1.2.7 赋值运算符=：把右边赋值给左边，即1.1变量与命名规则中1.1.2 理解”对象引用”的过程。 1.2.8 优先级算术运算 &gt; 比较运算 &gt; 逻辑运算，如：12In [31]: 3 + 5 &gt; 1 +2 and 1 != 2Out[31]: True 模糊不清时，建议使用小括号(小括号可以嵌套，内层的小括号优先级高于外层的)，如：1234In [32]: 2 * 3 ** 2 Out[32]: 18In [33]: ( 2 * 3 ) ** 2Out[33]: 36 算术运算符中**优先级高于*、/。","tags":[{"name":"Python","slug":"Python","permalink":"http://www.linuxer.vip/tags/Python/"}]},{"title":"1.1变量与命名规则","date":"2016-12-14T06:26:50.000Z","path":"2016/12/14/1-1变量与命名规则/","text":"1.1.1 变量Python是一种强类型动态语言。 强类型：Python中所有的变量都有数据类型 动态：Python中变量的数据类型可以改变 Python没有严格意义上的常量，都是可变的，可以随意改变数据类型。 示例：123456789101112131415161718In [19]: foo = 1In [20]: type(foo)Out[20]: intIn [21]: foo = 3.1415926In [22]: type(foo)Out[22]: floatIn [23]: foo = 'helloworld'In [24]: type(foo)Out[24]: strIn [25]: foo = TrueIn [26]: type(foo)Out[26]: boolIn [27]: foo = NoneIn [28]: type(foo)Out[28]: NoneTypeIn [31]: lst = [1,2,3,4,5]In [32]: type(lst)Out[32]: list 注 type()用来查看对象的数据类型 1.1.2 理解”对象引用”Python将所有数据存储为内存对象，而变量就是在程序中用来指向这些内存对象的，对变量赋值就是将一个变量指向一个内存对象的过程，这个过程称为”对象引用”。 1foo = 'ABC' 当我们运行上面这段程序是，Python解释器其实做了这些事情： 创建一个字符串类型的内存对象，存储为’ABC’ 创建一个名为foo的变量，并指向’ABC’这个内存对象 示例：1234567In [33]: a = 'ABC'In [34]: b = aIn [35]: a = 'XYZ'In [36]: print(a)XYZIn [37]: print(b)ABC 过程理解： a = &#39;ABC&#39;：a -指向-&gt; ‘ABC’ b = a：a -指向-&gt; ‘ABC’b -指向-&gt; ‘ABC’ a = &#39;XYZ&#39;：a -指向-&gt; ‘XYZ’b -指向-&gt; ‘ABC’ 1.1.3 变量命名规则 变量名只能包含字母、数字和下划线(_) 变量名只能以字母或下划线(_)开头 变量名不能是Python解释器中的保留字 更详细的命名规则，可参照Python的PEP8规范","tags":[{"name":"Python","slug":"Python","permalink":"http://www.linuxer.vip/tags/Python/"}]},{"title":"Python基础之开发环境-使用","date":"2016-12-14T01:39:22.000Z","path":"2016/12/14/Python基础之开发环境-使用/","text":"pyenv命令格式1pyenv &lt;command&gt; [&lt;args&gt;] pyenv命令帮助12pyenv help #查看pyenv可用的子命令pyenv help &lt;command&gt; #查看pyenv子命令的帮助 常用命令介绍1. install12pyenv install -l|--list #显示可通过pyenv安装python的所有可用版本pyenv install [-f|--force] &lt;version&gt; #安装指定版本的python，-f|--force表示强制安装(如果已经安装了指定版本的python) 注意: 安装时pyenv是从Python官网下载，速度会比较慢。我们可以将下载好的Python源码包(如：Python-3.5.2.tar.xz)放置于~/.pyenv/cache/下(如果没有cache目录，请自行创建)，再进行install安装，这就省去了从Python官网下载指定Python版本的过程。 示例：1234pyenv install 3.5.2输出:pyenv: /root/.pyenv/versions/3.5.2 already existscontinue with installation? (y/N) #我已经安装过Python-3.5.2，不再往下继续安装 2. uninstall1pyenv uninstall &lt;version&gt; 卸载指定版本的python 3. local1pyenv local &lt;version&gt; 切换当前目录及其子目录使用指定的Python版本。 示例：1234567891011121314mkdir py3.5.2 #创建py3.5.2目录cd py3.5.2 #切换至3.5.2目录pyenv local 3.5.2 #是当前目录python版本为3.5.2python -V #查看当前目录的python版本输出:Python 3.5.2pip -V #查看当前目录的pip版本输出:pip 8.1.1 from /root/.pyenv/versions/3.5.2/lib/python3.5/site-packages (python 3.5)mkdir test #在py3.5.2目录下创建子目录，名为testcd test/ #切换至test目录python -V #查看test目录的python版本输出:Python 3.5.2 4. version1pyenv version 查看当前选择的python版本。 示例：123pyenv version输出:3.5.2 (set by /root/py3.5.2/.python-version) 5. versions1pyenv versions 查看所有在$PYENV_ROOT/versions/*下的python版本 示例：12345pyenv versions system* 3.5.2 (set by /root/py3.5.2/.python-version) 3.5.2/envs/shwang shwang 说明:1.* 表示当前目录使用的python版本2.system 表示系统自带的python版本 6. commands1pyenv commands 显示所有pyenv命令。 7. virtualenv1pyenv virtualenv [version] &lt;virtualenv-name&gt; 基于指定version创建python虚拟环境。用途：通过创建独立Python开发环境的工具,来解决依赖、版本以及间接权限问题。引用自 简书 示例：1234567891011121314cd py3.5.2/ #切换至py3.5.2目录pyenv virtualenv 3.5.2 venv3.5.2 #基于python3.5.2创建名为venv3.5.2的虚拟环境输出:Ignoring indexes: https://pypi.python.org/simpleRequirement already satisfied (use --upgrade to upgrade): setuptools in /root/.pyenv/versions/3.5.2/envs/venv3.5.2/lib/python3.5/site-packagesRequirement already satisfied (use --upgrade to upgrade): pip in /root/.pyenv/versions/3.5.2/envs/venv3.5.2/lib/python3.5/site-packagespyenv local venv3.5.2(venv3.5.2) [root@localhost py3.5.2]# pyenv local venv3.5.2pyenv version输出:venv3.5.2 (set by /root/py3.5.2/.python-version)pip install jupyter #安装jupyterls /root/.pyenv/versions/venv3.5.2/bin/jupyter* #在该目录下生成jupyter相关的二进制命令ls /root/.pyenv/versions/3.5.2/bin/ #在该目录下没有和jupyter相关的命令 注 更改pip使用的镜像源123456789cat ~/.pip/pip.conf[global]#阿里云 index-url = http://mirrors.aliyun.com/pypi/simple/#豆瓣# index-url = http://pypi.doubanio.com/simple/#清华# index-url = http://mirrors.tuna.tsinghua.edu.cn/pypi/web/simple/ trusted-host = mirrors.aliyun.com","tags":[{"name":"Python","slug":"Python","permalink":"http://www.linuxer.vip/tags/Python/"}]},{"title":"Python基础之开发环境-安装","date":"2016-11-18T13:55:25.000Z","path":"2016/11/18/Python基础之开发环境-安装/","text":"pyenv是什么？简单的Python版本管理器 pyenv有哪些功能？ 安装Python解释器 管理Python版本 管理Python虚拟环境（后续会有介绍什么是Python虚拟环境，待续…） …… 安装pyenv系统环境:CentOS 7 pyenv项目地址 安装依赖 git、gcc、make、patch、zlib-devel、gdbm-devel、openssl-devel、sqlite-devel、readline-devel、bzip2-devel 使用pyenv-install安装pyenv 1$ curl -L https://raw.githubusercontent.com/yyuu/pyenv-installer/master/bin/pyenv-installer | bash 配置环境变量 添加以下内容至~/.bash_profile 123export PATH=&quot;/root/.pyenv/bin:$PATH&quot;eval &quot;$(pyenv init -)&quot;eval &quot;$(pyenv virtualenv-init -)&quot; 至此，pyenv安装完成。","tags":[{"name":"Python","slug":"Python","permalink":"http://www.linuxer.vip/tags/Python/"}]}]